# 브라우저 렌더링 원리
### 홈페이지가 사용자에게 보이는 순서에 대해 설명해주세요.

> 1. HTML, CSS 다운로드  
> 2. 다운받은 HTML과 CSS를 각 DOM과 CSSOM ( OM = Object Model)로 만든다.
> 3. 만들어진 DOM, CSSOM을 이용하여 렌더 트리를 생성  
> ( 렌더트리의 목적: 표시해야 할 순서와 문서의 시각적인 구성 요소로써 올바른 순서로 내용을 그려낼 수 있도록 하기 위한 목적 )  
> ( 렌더 트리에는 실제 화면에 표현되는 요소들로만 구성 됨. )
> 4. 렌더 트리 배치
> 5. 이 렌더 트리를 그리는 과정을 통해 브라우저가 서버에 요청한 내용들을 픽셀화 시키는 것을 브라우저 렌더링이라고 한다.

# 호이스팅에 대해 설명해주세요.

### 호이스팅 ( Hoisting )의 개념
`함수 안에 있는 선언들을 모두 끌어올려서 해당 함수 유효 범위의 최상단에 선언하는 것을 말한다.`

> let / const 변수 선언과 함수표현식에는 호이스팅이 발생하지 않는다.
> var 함수 선언과 함수선언식에서만 호이스팅이 발생한다. var변수 / 함수 선언만 위로 끌어 올려지며, 할당은 끌어 올려지지 않는다.

# 클로저는 무엇 인가요, 왜 이러한 패턴을 사용하는가
> 자바스크립트는 함수 안에 함수를 선언할 수 있다.  
> 먼저 선언된 함수를 외부함수라 정의하고, 이후에 정의된 함수를 내부함수라 정의한다면,  
> 기본적으로 내부함수는 외부함수의 요소에 접근이 가능하다.   
> 외부함수의 수명이 다해 외부함수가 종료(리턴)된 후에도 외부함수의 변수에 내부함수가 접근할수 있는 `자바스크립트의 매커니즘`을 `클로저`라고 한다.

# CSS에서 margin과 padding에 대해 설명해주세요.

* margin: 각 측면(상하좌우)에 대한 바깥쪽 여백을 설정하는 속성이 있다.  
margin-top,right,bottom,left 이를 이용하여 요소의 각 바깥쪽 여백을 통제할 수 있다.

추가적으로 위의 4가지 속성들은 다음 값들을 가질 수 있다.  
1. auto: 브라우저가 여백을 계산한다. ( 컨테이너 내의 가로중앙에 배치함 )
2. length: 여백(=margin)을 pt,px,cm등으로 margin을 지정한다.
3. %: 포함하는 요소 너비의 %로 margin을 지정한다.
4. inherit: 여백이 상위 요소에서 상속되어야 함을 지정한다.
( 음수값은 지정되지 않음 )
5. 속기 속성을 이용하여 코드를 줄일 수 있다. 왼쪽부터 top,right,bottom,left 순서이다.  
ex) margin: 10px 5px 8px 9px;

* padding: 긱 측면(상하좌우)에 대한 안쪽 여백을 설정하는 속성이 있다.
padding-top,right,bottom,left 이를 이용하여 요소의 각 안쪽 여백을 통제할 수 있다.

padding 또한 다음 값들을 가질 수 있다.
1. length: pt,px,cm 등으로 padding을 지정한다.
2. %: 포함하는 요소 너비의 %로 padding을 지정한다.
3. inherit: padding이 상위 요소에서 상속되어야 함을 지정한다. ( 이 또한 음수값은 허용되지 않음 )
4. margin과 마찬가지로 속기 속성을 이용하여 코드를 줄일 수 있다.  
ex) padding: 10px 5px 8px 9px;

# CSS에서 position은 어떻게 사용하는지 설명해주세요.

* position: HTML 요소를 배치하는 방법을 정의하는 속성

position 속성에 쓸수 있는 5개의 값들이 있다.
static, relative, absolute, fixed, sticky

### static
static은 element(요소)가 문서(HTML)에서 일반적인 흐름에 따라 배치가 된다.
static은 element에 position값을 지정하지 않았을 때 적용되는 값이다.

* static의 경우 top,right,bottom,left,z-index 등의 속성이 아무 영향도 주지 못한다.  
사용하고 싶다면 position: relative;

### relative
static과 똑같이 요소가 문서에서 일반적인 흐름에 따라 배치 된다.

* static과 차이점은 element가 자신의 static 위치에서 top,right,bottom,left 와 같은 속성에 의한 상대적인(relative) 위치에 배치된다는 점이다.
* relative는 top,right,bottom,left 와 같으 속성을 사용하지 않았을때 static과 똑같은 위치에 배치 된다.
* relative로 지정한 요소는 다른 요소들의 위치에 영향을 주지 않는 특징이 있다.

### absolute
absolute는 element가 문서의 일반적인 흐름을 따라 배치되지 않고, 가장 가까운 위치에 있는 부모 요소에 대해 상대적으로 위치가 배정되는 속성이다.

* 부모 요소가 없으면 HTML BODY ( 문서 본문 )을 기준으로 삼고 페이지 스크롤에 따라 움직인다.

### fixed
fixed 역시 absolute와 마찬가지로 요소가 문서의 일반적인 흐름을 따라 배치되지 않고, 스크린의 뷰포트를 기준으로 한 위치에 배치된다. 즉, 스크롤해도 움직이지 않는 고정된 위치에 배치된다.

### sticky
sticky는 요소가 일반적인 문서의 흐름을 따라 배치되며 top,right,bottom,left 속성들의 값을 기준으로 flow root 및 해당 요소를 포함하는 containing block에 대한 상대적 위치에 배치된다.  
즉, fixed와 같지만 차이점은 fixed는 문서의 흐름을 따르지 않고 뷰포트를 기준으로 배치가 되는 반면 sticky는 문서의 흐름을 따르면서 containing box를 기준으로 상대적인 위치를 기준으로 배치가 된다는 점이다.

# GET과 POST의 차이

`GET: 서버로부터 데이터를 조회하기 위해 사용되는 HTTP 메소드`  
GET 요청의 특징  
* 요청을 전송할 때 필요한 데이터를 BODY에 담지 않고, 쿼리스트링을 통해 전송한다.
* 불필요한 요청을 제한하기 위해 요청이 캐시될수 있다.  
> ex) js,css,이미지 같은 정적 컨텐츠는 데이터양이 크고, 변경될 일이 적어서 반복하여 동일한 요청을 보낼 필요가 없는데, 이 때문에 정적 컨텐츠를 요청하고 나면 브라우저에서는 요청을 캐시해두고, 동일한 요청이 발생할 때 서버로 요청을 보내지 않고 캐시된 데이터를 사용하는 경우.

`POST: 서버로 데이터를 보내기 위해 사용되는 HTTP 메소드`
POST 요청의 특징
* GET과 달리 전송해야할 데이터를 HTTP 메세지의 BODY에 담아서 전송  
( HTTP 메세지의 BODY는 길이의 제한없이 데이터를 전송할 수 있다. )
* 대용량 데이터를 전송할 수 있다.
* 요청 헤더의 Content-Type에 요청 데이터의 타입을 표시해야 한다.  
( 데이터 타입을 알 수 없는 경우 application/octet-stream으로 요청을 처리한다. )

### GET과 POST의 차이점
* GET은 동일한 연산을 여러 번 수행하더라도 동일한 결과가 나타나게 설계되었고, POST는 그렇지 않게 설계되었다.
* GET은 동일한 연산을 여러 번 수행했을때 동일한 결과가 나타나는 경우에 따라 사용되기 때문에 주로 조회할 때 사용된다.
* POST는 서버에게 동일한 요청을 여러 번 전송해도 응답은 항상 다를 수 있다. 이 때문에 POST는 주로 서버의 상태가 데이터를 변경시킬때 사용된다.
